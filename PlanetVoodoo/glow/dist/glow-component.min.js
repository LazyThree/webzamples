(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){THREE.BufferGeometryUtils={computeTangents:function(geometry){geometry.computeTangents();console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.")},mergeBufferGeometries:function(geometries,useGroups){var isIndexed=geometries[0].index!==null;var attributesUsed=new Set(Object.keys(geometries[0].attributes));var morphAttributesUsed=new Set(Object.keys(geometries[0].morphAttributes));var attributes={};var morphAttributes={};var morphTargetsRelative=geometries[0].morphTargetsRelative;var mergedGeometry=new THREE.BufferGeometry;var offset=0;for(var i=0;i<geometries.length;++i){var geometry=geometries[i];var attributesCount=0;if(isIndexed!==(geometry.index!==null)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");return null}for(var name in geometry.attributes){if(!attributesUsed.has(name)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+name+'" attribute exists among all geometries, or in none of them.');return null}if(attributes[name]===undefined)attributes[name]=[];attributes[name].push(geometry.attributes[name]);attributesCount++}if(attributesCount!==attributesUsed.size){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes.");return null}if(morphTargetsRelative!==geometry.morphTargetsRelative){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries.");return null}for(var name in geometry.morphAttributes){if(!morphAttributesUsed.has(name)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries.");return null}if(morphAttributes[name]===undefined)morphAttributes[name]=[];morphAttributes[name].push(geometry.morphAttributes[name])}mergedGeometry.userData.mergedUserData=mergedGeometry.userData.mergedUserData||[];mergedGeometry.userData.mergedUserData.push(geometry.userData);if(useGroups){var count;if(isIndexed){count=geometry.index.count}else if(geometry.attributes.position!==undefined){count=geometry.attributes.position.count}else{console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute");return null}mergedGeometry.addGroup(offset,count,i);offset+=count}}if(isIndexed){var indexOffset=0;var mergedIndex=[];for(var i=0;i<geometries.length;++i){var index=geometries[i].index;for(var j=0;j<index.count;++j){mergedIndex.push(index.getX(j)+indexOffset)}indexOffset+=geometries[i].attributes.position.count}mergedGeometry.setIndex(mergedIndex)}for(var name in attributes){var mergedAttribute=this.mergeBufferAttributes(attributes[name]);if(!mergedAttribute){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+name+" attribute.");return null}mergedGeometry.setAttribute(name,mergedAttribute)}for(var name in morphAttributes){var numMorphTargets=morphAttributes[name][0].length;if(numMorphTargets===0)break;mergedGeometry.morphAttributes=mergedGeometry.morphAttributes||{};mergedGeometry.morphAttributes[name]=[];for(var i=0;i<numMorphTargets;++i){var morphAttributesToMerge=[];for(var j=0;j<morphAttributes[name].length;++j){morphAttributesToMerge.push(morphAttributes[name][j][i])}var mergedMorphAttribute=this.mergeBufferAttributes(morphAttributesToMerge);if(!mergedMorphAttribute){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+name+" morphAttribute.");return null}mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)}}return mergedGeometry},mergeBufferAttributes:function(attributes){var TypedArray;var itemSize;var normalized;var arrayLength=0;for(var i=0;i<attributes.length;++i){var attribute=attributes[i];if(attribute.isInterleavedBufferAttribute){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.");return null}if(TypedArray===undefined)TypedArray=attribute.array.constructor;if(TypedArray!==attribute.array.constructor){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");return null}if(itemSize===undefined)itemSize=attribute.itemSize;if(itemSize!==attribute.itemSize){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");return null}if(normalized===undefined)normalized=attribute.normalized;if(normalized!==attribute.normalized){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");return null}arrayLength+=attribute.array.length}var array=new TypedArray(arrayLength);var offset=0;for(var i=0;i<attributes.length;++i){array.set(attributes[i].array,offset);offset+=attributes[i].array.length}return new THREE.BufferAttribute(array,itemSize,normalized)},interleaveAttributes:function(attributes){var TypedArray;var arrayLength=0;var stride=0;for(var i=0,l=attributes.length;i<l;++i){var attribute=attributes[i];if(TypedArray===undefined)TypedArray=attribute.array.constructor;if(TypedArray!==attribute.array.constructor){console.error("AttributeBuffers of different types cannot be interleaved");return null}arrayLength+=attribute.array.length;stride+=attribute.itemSize}var interleavedBuffer=new THREE.InterleavedBuffer(new TypedArray(arrayLength),stride);var offset=0;var res=[];var getters=["getX","getY","getZ","getW"];var setters=["setX","setY","setZ","setW"];for(var j=0,l=attributes.length;j<l;j++){var attribute=attributes[j];var itemSize=attribute.itemSize;var count=attribute.count;var iba=new THREE.InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,attribute.normalized);res.push(iba);offset+=itemSize;for(var c=0;c<count;c++){for(var k=0;k<itemSize;k++){iba[setters[k]](c,attribute[getters[k]](c))}}}return res},estimateBytesUsed:function(geometry){var mem=0;for(var name in geometry.attributes){var attr=geometry.getAttribute(name);mem+=attr.count*attr.itemSize*attr.array.BYTES_PER_ELEMENT}var indices=geometry.getIndex();mem+=indices?indices.count*indices.itemSize*indices.array.BYTES_PER_ELEMENT:0;return mem},mergeVertices:function(geometry,tolerance=1e-4){tolerance=Math.max(tolerance,Number.EPSILON);var hashToIndex={};var indices=geometry.getIndex();var positions=geometry.getAttribute("position");var vertexCount=indices?indices.count:positions.count;var nextIndex=0;var attributeNames=Object.keys(geometry.attributes);var attrArrays={};var morphAttrsArrays={};var newIndices=[];var getters=["getX","getY","getZ","getW"];for(var i=0,l=attributeNames.length;i<l;i++){var name=attributeNames[i];attrArrays[name]=[];var morphAttr=geometry.morphAttributes[name];if(morphAttr){morphAttrsArrays[name]=new Array(morphAttr.length).fill().map(()=>[])}}var decimalShift=Math.log10(1/tolerance);var shiftMultiplier=Math.pow(10,decimalShift);for(var i=0;i<vertexCount;i++){var index=indices?indices.getX(i):i;var hash="";for(var j=0,l=attributeNames.length;j<l;j++){var name=attributeNames[j];var attribute=geometry.getAttribute(name);var itemSize=attribute.itemSize;for(var k=0;k<itemSize;k++){hash+=`${~~(attribute[getters[k]](index)*shiftMultiplier)},`}}if(hash in hashToIndex){newIndices.push(hashToIndex[hash])}else{for(var j=0,l=attributeNames.length;j<l;j++){var name=attributeNames[j];var attribute=geometry.getAttribute(name);var morphAttr=geometry.morphAttributes[name];var itemSize=attribute.itemSize;var newarray=attrArrays[name];var newMorphArrays=morphAttrsArrays[name];for(var k=0;k<itemSize;k++){var getterFunc=getters[k];newarray.push(attribute[getterFunc](index));if(morphAttr){for(var m=0,ml=morphAttr.length;m<ml;m++){newMorphArrays[m].push(morphAttr[m][getterFunc](index))}}}}hashToIndex[hash]=nextIndex;newIndices.push(nextIndex);nextIndex++}}const result=geometry.clone();for(var i=0,l=attributeNames.length;i<l;i++){var name=attributeNames[i];var oldAttribute=geometry.getAttribute(name);var buffer=new oldAttribute.array.constructor(attrArrays[name]);var attribute=new THREE.BufferAttribute(buffer,oldAttribute.itemSize,oldAttribute.normalized);result.setAttribute(name,attribute);if(name in morphAttrsArrays){for(var j=0;j<morphAttrsArrays[name].length;j++){var oldMorphAttribute=geometry.morphAttributes[name][j];var buffer=new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);var morphAttribute=new THREE.BufferAttribute(buffer,oldMorphAttribute.itemSize,oldMorphAttribute.normalized);result.morphAttributes[name][j]=morphAttribute}}}result.setIndex(newIndices);return result},toTrianglesDrawMode:function(geometry,drawMode){if(drawMode===THREE.TrianglesDrawMode){console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");return geometry}if(drawMode===THREE.TriangleFanDrawMode||drawMode===THREE.TriangleStripDrawMode){var index=geometry.getIndex();if(index===null){var indices=[];var position=geometry.getAttribute("position");if(position!==undefined){for(var i=0;i<position.count;i++){indices.push(i)}geometry.setIndex(indices);index=geometry.getIndex()}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");return geometry}}var numberOfTriangles=index.count-2;var newIndices=[];if(drawMode===THREE.TriangleFanDrawMode){for(var i=1;i<=numberOfTriangles;i++){newIndices.push(index.getX(0));newIndices.push(index.getX(i));newIndices.push(index.getX(i+1))}}else{for(var i=0;i<numberOfTriangles;i++){if(i%2===0){newIndices.push(index.getX(i));newIndices.push(index.getX(i+1));newIndices.push(index.getX(i+2))}else{newIndices.push(index.getX(i+2));newIndices.push(index.getX(i+1));newIndices.push(index.getX(i))}}}if(newIndices.length/3!==numberOfTriangles){console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.")}var newGeometry=geometry.clone();newGeometry.setIndex(newIndices);newGeometry.clearGroups();return newGeometry}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",drawMode);return geometry}},computeMorphedAttributes:function(object){if(object.geometry.isBufferGeometry!==true){console.error("THREE.BufferGeometryUtils: Geometry is not of type THREE.BufferGeometry.");return null}var _vA=new THREE.Vector3;var _vB=new THREE.Vector3;var _vC=new THREE.Vector3;var _tempA=new THREE.Vector3;var _tempB=new THREE.Vector3;var _tempC=new THREE.Vector3;var _morphA=new THREE.Vector3;var _morphB=new THREE.Vector3;var _morphC=new THREE.Vector3;function _calculateMorphedAttributeData(object,material,attribute,morphAttribute,morphTargetsRelative,a,b,c,modifiedAttributeArray){_vA.fromBufferAttribute(attribute,a);_vB.fromBufferAttribute(attribute,b);_vC.fromBufferAttribute(attribute,c);var morphInfluences=object.morphTargetInfluences;if(material.morphTargets&&morphAttribute&&morphInfluences){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(var i=0,il=morphAttribute.length;i<il;i++){var influence=morphInfluences[i];var morph=morphAttribute[i];if(influence===0)continue;_tempA.fromBufferAttribute(morph,a);_tempB.fromBufferAttribute(morph,b);_tempC.fromBufferAttribute(morph,c);if(morphTargetsRelative){_morphA.addScaledVector(_tempA,influence);_morphB.addScaledVector(_tempB,influence);_morphC.addScaledVector(_tempC,influence)}else{_morphA.addScaledVector(_tempA.sub(_vA),influence);_morphB.addScaledVector(_tempB.sub(_vB),influence);_morphC.addScaledVector(_tempC.sub(_vC),influence)}}_vA.add(_morphA);_vB.add(_morphB);_vC.add(_morphC)}if(object.isSkinnedMesh){object.boneTransform(a,_vA);object.boneTransform(b,_vB);object.boneTransform(c,_vC)}modifiedAttributeArray[a*3+0]=_vA.x;modifiedAttributeArray[a*3+1]=_vA.y;modifiedAttributeArray[a*3+2]=_vA.z;modifiedAttributeArray[b*3+0]=_vB.x;modifiedAttributeArray[b*3+1]=_vB.y;modifiedAttributeArray[b*3+2]=_vB.z;modifiedAttributeArray[c*3+0]=_vC.x;modifiedAttributeArray[c*3+1]=_vC.y;modifiedAttributeArray[c*3+2]=_vC.z}var geometry=object.geometry;var material=object.material;var a,b,c;var index=geometry.index;var positionAttribute=geometry.attributes.position;var morphPosition=geometry.morphAttributes.position;var morphTargetsRelative=geometry.morphTargetsRelative;var normalAttribute=geometry.attributes.normal;var morphNormal=geometry.morphAttributes.position;var groups=geometry.groups;var drawRange=geometry.drawRange;var i,j,il,jl;var group,groupMaterial;var start,end;var modifiedPosition=new Float32Array(positionAttribute.count*positionAttribute.itemSize);var modifiedNormal=new Float32Array(normalAttribute.count*normalAttribute.itemSize);if(index!==null){if(Array.isArray(material)){for(i=0,il=groups.length;i<il;i++){group=groups[i];groupMaterial=material[group.materialIndex];start=Math.max(group.start,drawRange.start);end=Math.min(group.start+group.count,drawRange.start+drawRange.count);for(j=start,jl=end;j<jl;j+=3){a=index.getX(j);b=index.getX(j+1);c=index.getX(j+2);_calculateMorphedAttributeData(object,groupMaterial,positionAttribute,morphPosition,morphTargetsRelative,a,b,c,modifiedPosition);_calculateMorphedAttributeData(object,groupMaterial,normalAttribute,morphNormal,morphTargetsRelative,a,b,c,modifiedNormal)}}}else{start=Math.max(0,drawRange.start);end=Math.min(index.count,drawRange.start+drawRange.count);for(i=start,il=end;i<il;i+=3){a=index.getX(i);b=index.getX(i+1);c=index.getX(i+2);_calculateMorphedAttributeData(object,material,positionAttribute,morphPosition,morphTargetsRelative,a,b,c,modifiedPosition);_calculateMorphedAttributeData(object,material,normalAttribute,morphNormal,morphTargetsRelative,a,b,c,modifiedNormal)}}}else if(positionAttribute!==undefined){if(Array.isArray(material)){for(i=0,il=groups.length;i<il;i++){group=groups[i];groupMaterial=material[group.materialIndex];start=Math.max(group.start,drawRange.start);end=Math.min(group.start+group.count,drawRange.start+drawRange.count);for(j=start,jl=end;j<jl;j+=3){a=j;b=j+1;c=j+2;_calculateMorphedAttributeData(object,groupMaterial,positionAttribute,morphPosition,morphTargetsRelative,a,b,c,modifiedPosition);_calculateMorphedAttributeData(object,groupMaterial,normalAttribute,morphNormal,morphTargetsRelative,a,b,c,modifiedNormal)}}}else{start=Math.max(0,drawRange.start);end=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(i=start,il=end;i<il;i+=3){a=i;b=i+1;c=i+2;_calculateMorphedAttributeData(object,material,positionAttribute,morphPosition,morphTargetsRelative,a,b,c,modifiedPosition);_calculateMorphedAttributeData(object,material,normalAttribute,morphNormal,morphTargetsRelative,a,b,c,modifiedNormal)}}}var morphedPositionAttribute=new THREE.Float32BufferAttribute(modifiedPosition,3);var morphedNormalAttribute=new THREE.Float32BufferAttribute(modifiedNormal,3);return{positionAttribute:positionAttribute,normalAttribute:normalAttribute,morphedPositionAttribute:morphedPositionAttribute,morphedNormalAttribute:morphedNormalAttribute}}}},{}],2:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.component=void 0;require("../lib/BufferGeometryUtils.js");const component=AFRAME.registerComponent("glow",{schema:{intensityPower:{default:2.4},intensityBase:{default:1},glowColor:{type:"color",default:"#ff0"}},init:function(){const vshader=`\n            uniform vec3 viewVector;\n            uniform float intensityBase;\n            uniform float intensityPower;\n            varying float intensity;\n            void main() {\n                vec3 vNormal = normalize( normalMatrix * normal );\n\t            vec3 vNormel = normalize( normalMatrix * viewVector );\n\t            intensity = pow( intensityBase - dot(vNormal, vNormel), intensityPower );\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }\n        `;const fshader=`\n        uniform vec3 glowColor;\n        varying float intensity;\n        void main() {\n\t        vec3 glow = glowColor * intensity;\n            gl_FragColor = vec4( glow, 1.0 );\n        }\n        `;this.viewVector=new THREE.Vector3;this.worldpos=new THREE.Vector3;var glowColor=new THREE.Color(255);this.glowMaterial=new THREE.ShaderMaterial({uniforms:{intensityBase:{type:"f",value:this.data.intensityBase},intensityPower:{type:"f",value:this.data.intensityPower},glowColor:{type:"c",value:glowColor},viewVector:{type:"v3",value:this.viewVector}},vertexShader:vshader,fragmentShader:fshader,side:THREE.FrontSide,blending:THREE.AdditiveBlending,transparent:true});const modelComponent=this.el.components["gltf-model"];if(modelComponent){this.handleModel=this.handleModel.bind(this);this.el.addEventListener("model-loaded",this.handleModel)}else{const oldMaterial=this.el.getObject3D("mesh").material;this.el.getObject3D("mesh").material=this.glowMaterial;oldMaterial.dispose()}},handleModel:function(evt){if(evt.target!==this.el)return;const mesh=this.el.getObject3D("mesh");mesh.parent.remove(mesh);var geometry=null;mesh.traverse(node=>{if(!node.geometry)return;if(!geometry){geometry=node.geometry}else{geometry=THREE.BufferGeometryUtils.mergeBufferGeometries([geometry,node.geometry]);geometry=THREE.BufferGeometryUtils.mergeVertices(geometry)}node.geometry.dispose();node.material.dispose()});const newModel=new THREE.Mesh(geometry,this.glowMaterial);this.el.object3D.add(newModel)},tick:function(t,dt){if(this.el.sceneEl.camera){const cameraRig=this.el.sceneEl.camera.el.object3D;this.el.object3D.getWorldPosition(this.worldpos);this.viewVector.subVectors(cameraRig.position,this.worldpos);this.glowMaterial.uniforms.viewVector.value=this.viewVector;this.glowMaterial.needsUpdate=true}},update:function(oldData){const changes=AFRAME.utils.diff(oldData,this.data);if(!changes)return;if(changes.glowColor){this.glowMaterial.uniforms.glowColor.value.setStyle(changes.glowColor);this.glowMaterial.needsUpdate=true;delete changes.glowColor}for(let prop in changes){this.glowMaterial.uniforms[prop].value=changes[prop];this.glowMaterial.needsUpdate=true}},remove:function(){this.el.object3D.remove(this.sprite);this.sprite.material.dispose()}});exports.component=component},{"../lib/BufferGeometryUtils.js":1}]},{},[2]);
